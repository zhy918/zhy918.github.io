{"meta":{"title":"贝贝张的博客","subtitle":null,"description":"贝贝张的博客","author":"贝贝张","url":"https://zhy918.github.io"},"pages":[{"title":"","date":"un66fin66","updated":"un66fin66","comments":true,"path":"about/index.html","permalink":"https://zhy918.github.io/about/index.html","excerpt":"","text":"关于我从事 WEB 开发，主要开发语言 html css js，熟悉使用 jqurey、bootstrap 等主流框架；对 vue.js 情有独钟；有一定的代码洁癖。 对服务端、计算机网络等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：成都 关于学习正在往终身学习者前进…近期学习方向：java 关于座右铭 不为无益之事，何以遣有涯之生 关于爱好热爱运动，尤其喜爱骑自行车、哲学、旅行。 联系我 Blog: 贝贝 GitHub: zhy918 QQ: QQ"}],"posts":[{"title":"JavaScript原型链","slug":"JavaScript原型链","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/02/17/JavaScript原型链/","link":"","permalink":"https://zhy918.github.io/2019/02/17/JavaScript原型链/","excerpt":"","text":"JavaScript原型链一、原型对象看以下代码：123function Fun() &#123;&#125;;var fn = new Fun();console.log( fn.__proto__ === Fun.prototype ); // 输出true JavaScript中new一个新的对象实例分三步：123var fn=&#123;&#125;; fn.__proto__=Fun.prototype; Fun.call(fn); __proto__属性：可见，每个对象new时都会在其内部初始化一个__proto__属性，对象的__proto__属性指向其构造函数的prototype属性，对于对象实例来说，prototype就是它的原型对象。prototype属性：真实代码里不推荐是使用__proto__属性，因为这是一个设计上的失误，导致 __proto__属性是可以被修改的，同时意味着 JavaScript 的属性查找机制会因此而“瘫痪”，所以强烈的不建议使用它。如果你确实要通过一个对象访问其原型，使用方法：1Object.getPrototypeOf(fn) 二、原型链看以下代码：12console.log( typeof Fun.prototype ); // 输出Objectconsole.log( Fun.prototype.__proto__ === Object.prototype ); // 输出true __proto__的作用是在访问一个对象的属性时，如果该对象内部不存在这个属性，就会去该对象的__proto__属性所指向的那个原型对象（父对象）里找，如果原型对象（父对象）也不存在这个属性，则继续往原型对象的__proto__属性所指向的那个原型对象（爷爷对象）里找，如果还没找到，则继续往上找，直到原型链顶端null，若还没找到，则返回undefined，通过对象的__proto__属性一直向上访问属性的一条链即为原型链。。 三、原型链的顶端看以下代码：123456console.log(String.prototype.__proto__ === Object.prototype); // 输出trueconsole.log(Number.prototype.__proto__ === Object.prototype); // 输出trueconsole.log(Boolean.prototype.__proto__ === Object.prototype); // 输出trueconsole.log(Array.prototype.__proto__ === Object.prototype); // 输出trueconsole.log(Function.prototype.__proto__ === Object.prototype); // 输出trueconsole.log(Object.prototype.__proto__ === null) // 输出true 除了Object.prototype本身，对象的原型最终指向Object.prototype，null是原型链的顶端。Object.prototype的原型对象为空，Object.prototype是原型对象的源头，继承由此开始。 四、函数也是对象看以下代码：1console.log(Function.__proto__ === Function.prototype) // 输出true 函数也是对象，JavaScript的内置函数Function也不例外，对象Function的__proto__属性指向它的构造函数的prototype属性，Function.prototype即是它的原型对象。 五、constructor属性对象才都有constructor属性，constructor在原型链中作为对象prototype的属性存在，它从对象指向对象的构造函数，每个对象都有构造函数。 六、constructor的顶端123456console.log(String.constructor === Function);console.log(Number.constructor === Function);console.log(Boolean.constructor === Function);console.log(Array.constructor === Function);console.log(Object.constructor === Function);console.log(Function.constructor === Function); 可以看出Function的构造函数就是它自己，所有函数最终都是由Function构造得来，所以constructor属性的顶端是Function。 七、总结1、函数的prototype即是对象的原型对象2、通过对象的__proto__属性一直向上访问prototype属性的一条链即为原型链。3、对象独有的属性：__proto__和constructor；4、函数独有的属性：prototype，但JavaScript中函数也是对象，所以函数也有__proto__和constructor属性；5、constructor属性指向该对象的构造函数，最终指向Function。 参考博文：https://blog.csdn.net/cc18868876837/article/details/81211729","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhy918.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhy918.github.io/tags/JavaScript/"},{"name":"原型链","slug":"原型链","permalink":"https://zhy918.github.io/tags/原型链/"}]},{"title":"JavaScript闭包","slug":"JavaScript闭包","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2019/02/17/JavaScript闭包/","link":"","permalink":"https://zhy918.github.io/2019/02/17/JavaScript闭包/","excerpt":"","text":"JavaScript闭包一、变量的作用域要理解Javascript中的闭包，先理解变量的作用域。作用域：可以对数据进行访问操作的范围，分为全局作用域和局部作用域。Javascript中变量可分为全局变量和局部变量。全局变量：全局作用域内都可以被访问的变量。局部变量：只能在局部作用域被访问的变量，作用域以外不能被访问。12345678910111213&lt;script&gt;// 全局作用域var a = &apos;我是全局变量&apos;;function f1() &#123;// 局部作用域var b = &apos;局部变量&apos;;// 内部作用域可以访问全局变量aconsole.log(a);&#125;aa();// 外部作用域不能访问局部变量bconsole.log(b); // 报错 b is not defined&lt;/script&gt; 注意：在局部作用域（函数内部）声明变量时，不能省略var指令，否则将声明一个全局变量1234567function f1() &#123;// 由于未使用var声明变量c，c成为全局变量，变量c将能被全局访问c = &apos;我是局部作用域内的全局变量&apos;;&#125;// 函数必须要被调用其代码才会被执行f1();console.log(c); 二、闭包闭包：在主函数内部创建一个能够返回主函数内部变量的子函数叫闭包。看以下代码：12345678var add = function () &#123;var x = &apos;奥特曼&apos;return function () &#123;console.log(&apos;葫芦娃&apos;);return this;&#125; &#125;console.log(add()()); // 输出 葫芦娃 奥特曼 window 这时我们就可以在函数外部访问局部作用域内的变量x了 三、闭包的优点1、可以读取函数内部的变量2、让局部变量的值始终保持在内存中。 四、闭包的缺点1、闭包会让函数中的变量都被保存在内存中，内存消耗大，影响网页的性能，可能导致内存泄露，不能滥用闭包。在退出函数之前，删除不使用的局部变量。2、闭包会在父函数外部，改变父函数内部变量的值。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhy918.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhy918.github.io/tags/JavaScript/"},{"name":"闭包","slug":"闭包","permalink":"https://zhy918.github.io/tags/闭包/"}]},{"title":"Hexo主题MiHo","slug":"Hexo主题MiHo","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2019/02/16/Hexo主题MiHo/","link":"","permalink":"https://zhy918.github.io/2019/02/16/Hexo主题MiHo/","excerpt":"","text":"查看详细介绍：https://blog.minhow.com/2017/08/01/blog/installation-configuration/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhy918.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhy918.github.io/tags/Hexo/"},{"name":"博客主题","slug":"博客主题","permalink":"https://zhy918.github.io/tags/博客主题/"}]}]}