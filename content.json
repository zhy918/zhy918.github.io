{"meta":{"title":"贝贝张的博客","subtitle":null,"description":"贝贝张的博客","author":"贝贝张","url":"https://zhy918.github.io"},"pages":[{"title":"","date":"un11fin11","updated":"un11fin11","comments":true,"path":"about/index.html","permalink":"https://zhy918.github.io/about/index.html","excerpt":"","text":"关于我WEB 开发，主要开发语言 html css js，熟悉使用 jqurey、bootstrap 等主流框架；对 vue.js 情有独钟；有一定的代码洁癖。 对服务端、计算机网络等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：成都 关于学习正在往终身学习者前进…近期学习方向：java 关于座右铭 不为无益之事，何以遣有涯之生 关于爱好热爱运动，尤其喜爱骑自行车、哲学、旅行。 联系我 Blog: 贝贝 GitHub: zhy918 QQ: QQ"}],"posts":[{"title":"Vue CLI 3.x搭建","slug":"Vue CLI 3.x搭建","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2019/02/18/Vue CLI 3.x搭建/","link":"","permalink":"https://zhy918.github.io/2019/02/18/Vue CLI 3.x搭建/","excerpt":"","text":"一、Vue CLI介绍 Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供： 通过 @vue/cli 搭建交互式的项目脚手架。 通过 @vue/cli + @vue/cli-service-global 快速开始零配置原型开发。 一个运行时依赖 (@vue/cli-service)，该依赖： 可升级； 基于 webpack 构建，并带有合理的默认配置； 可以通过项目内的配置文件进行配置； 可以通过插件进行扩展。 一个丰富的官方插件集合，集成了前端生态中最好的工具。 一套完全图形化的创建和管理 Vue.js 项目的用户界面。 Vue CLI系统的组件包括： 1.CLICLI (@vue/cli) 是一个全局安装的 npm 包，提供了终端里的 vue 命令。它可以通过 vue create 快速创建一个新项目的脚手架，或者直接通过 vue serve 构建新想法的原型。你也可以通过 vue ui 通过一套图形化界面管理你的所有项目。我们会在接下来的指南中逐章节深入介绍。 2.CLI 服务CLI 服务 (@vue/cli-service) 是一个开发环境依赖。它是一个 npm 包，局部安装在每个 @vue/cli 创建的项目中。CLI 服务是构建于 webpack 和 webpack-dev-server 之上的。它包含了：加载其它 CLI 插件的核心服务；一个针对绝大部分应用优化过的内部的 webpack 配置；项目内部的 vue-cli-service 命令，提供 serve、build 和 inspect 命令。如果你熟悉 create-react-app 的话，@vue/cli-service 实际上大致等价于 react-scripts，尽管功能集合不一样。CLI 服务章节涵盖了它的具体用法。 3.CLI 插件CLI 插件是向你的 Vue 项目提供可选功能的 npm 包，例如 Babel/TypeScript 转译、ESLint 集成、单元测试和 end-to-end 测试等。Vue CLI 插件的名字以 @vue/cli-plugin- (内建插件) 或 vue-cli-plugin- (社区插件) 开头，非常容易使用。当你在项目内部运行 vue-cli-service 命令时，它会自动解析并加载 package.json 中列出的所有 CLI 插件。插件可以作为项目创建过程的一部分，或在后期加入到项目中。它们也可以被归成一组可复用的 preset。我们会在插件和 preset 章节进行深入讨论。 二、环境支持安装Vue CLI前需要安装Node.js的支持。Node 版本要求：Vue CLI 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。你可以使用 nvm 或 nvm-windows 在同一台电脑中管理多个 Node 版本。 三、安装Vue CLI 3.x 关于旧版本：Vue CLI 的包名称由 vue-cli 改成了 @vue/cli。 如果你已经全局安装了旧版本的 vue-cli (1.x 或 2.x)，你需要先通过 npm uninstall vue-cli -g 或 yarn global remove vue-cli 卸载它。 目前Vue CLI已经更新到3.4.0 在命令行工具内执行以下命令，安装Vue CLI 3.x：123npm install -g @vue/cli#或者yarn global add @vue/cli 检查Vue CLI版本1vue --version 四、创建Vue项目1、cd到要创建项目的文件夹下，输入：1vue create hlw hlw是项目名称 警告如果你在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作。你必须通过 winpty vue.cmd create hello-world 启动这个命令。不过，如果你仍想使用 vue create hello-world，则可以通过在 ~/.bashrc 文件中添加以下行来为命令添加别名。alias vue=’winpty vue.cmd’你需要重新启动 Git Bash 终端会话以使更新后的 bashrc 文件生效。 2、选择需要安装的功能你会被提示选取一个 preset。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。手动设置则提供了更多的选项，它们是面向生产的项目更加需要的选项释义：Babel：将ES6编译成ES5TypeScript：TypeScript语法，JS的超集Progressive Web App (PWA) Support：PWARouter：Vue路由Vuex：Vue状态管理CSS Pre-processors：CSS预处理器sass/lessLinter / Formatter：代码规范检查工具Unit Testing：单元测试E2E Testing：端到端测试 3、进入项目1cd hlw 4.启动项目1npm rum serve 五、项目目录结构 官网介绍：https://cli.vuejs.org/","categories":[{"name":"Vue","slug":"Vue","permalink":"https://zhy918.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://zhy918.github.io/tags/Vue/"},{"name":"Vue CLI 3.X","slug":"Vue-CLI-3-X","permalink":"https://zhy918.github.io/tags/Vue-CLI-3-X/"}]},{"title":"JavaScript闭包","slug":"JavaScript闭包","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2019/02/17/JavaScript闭包/","link":"","permalink":"https://zhy918.github.io/2019/02/17/JavaScript闭包/","excerpt":"","text":"JavaScript闭包一、变量的作用域要理解Javascript中的闭包，先理解变量的作用域。作用域：可以对数据进行访问操作的范围，分为全局作用域和局部作用域。Javascript中变量可分为全局变量和局部变量。全局变量：全局作用域内都可以被访问的变量。局部变量：只能在局部作用域被访问的变量，作用域以外不能被访问。12345678910111213&lt;script&gt;// 全局作用域var a = &apos;我是全局变量&apos;;function f1() &#123;// 局部作用域var b = &apos;局部变量&apos;;// 内部作用域可以访问全局变量aconsole.log(a);&#125;aa();// 外部作用域不能访问局部变量bconsole.log(b); // 报错 b is not defined&lt;/script&gt; 注意：在局部作用域（函数内部）声明变量时，不能省略var指令，否则将声明一个全局变量1234567function f1() &#123;// 由于未使用var声明变量c，c成为全局变量，变量c将能被全局访问c = &apos;我是局部作用域内的全局变量&apos;;&#125;// 函数必须要被调用其代码才会被执行f1();console.log(c); 二、闭包闭包：在主函数内部创建一个能够返回主函数内部变量的子函数叫闭包。看以下代码：12345678var add = function () &#123;var x = &apos;奥特曼&apos;return function () &#123;console.log(&apos;葫芦娃&apos;);return this;&#125; &#125;console.log(add()()); // 输出 葫芦娃 奥特曼 window 这时我们就可以在函数外部访问局部作用域内的变量x了 三、闭包的优点1、可以读取函数内部的变量2、让局部变量的值始终保持在内存中。 四、闭包的缺点1、闭包会让函数中的变量都被保存在内存中，内存消耗大，影响网页的性能，可能导致内存泄露，不能滥用闭包。在退出函数之前，删除不使用的局部变量。2、闭包会在父函数外部，改变父函数内部变量的值。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhy918.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhy918.github.io/tags/JavaScript/"},{"name":"闭包","slug":"闭包","permalink":"https://zhy918.github.io/tags/闭包/"}]},{"title":"JavaScript原型链","slug":"JavaScript原型链","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/02/17/JavaScript原型链/","link":"","permalink":"https://zhy918.github.io/2019/02/17/JavaScript原型链/","excerpt":"","text":"JavaScript原型链一、原型对象看以下代码：123function Fun() &#123;&#125;;var fn = new Fun();console.log( fn.__proto__ === Fun.prototype ); // 输出true JavaScript中new一个新的对象实例分三步：123var fn=&#123;&#125;; fn.__proto__=Fun.prototype; Fun.call(fn); __proto__属性：可见，每个对象new时都会在其内部初始化一个__proto__属性，对象的__proto__属性指向其构造函数的prototype属性，对于对象实例来说，prototype就是它的原型对象。prototype属性：真实代码里不推荐是使用__proto__属性，因为这是一个设计上的失误，导致 __proto__属性是可以被修改的，同时意味着 JavaScript 的属性查找机制会因此而“瘫痪”，所以强烈的不建议使用它。如果你确实要通过一个对象访问其原型，使用方法：1Object.getPrototypeOf(fn) 二、原型链看以下代码：12console.log( typeof Fun.prototype ); // 输出Objectconsole.log( Fun.prototype.__proto__ === Object.prototype ); // 输出true __proto__的作用是在访问一个对象的属性时，如果该对象内部不存在这个属性，就会去该对象的__proto__属性所指向的那个原型对象（父对象）里找，如果原型对象（父对象）也不存在这个属性，则继续往原型对象的__proto__属性所指向的那个原型对象（爷爷对象）里找，如果还没找到，则继续往上找，直到原型链顶端null，若还没找到，则返回undefined，通过对象的__proto__属性一直向上访问属性的一条链即为原型链。。 三、原型链的顶端看以下代码：123456console.log(String.prototype.__proto__ === Object.prototype); // 输出trueconsole.log(Number.prototype.__proto__ === Object.prototype); // 输出trueconsole.log(Boolean.prototype.__proto__ === Object.prototype); // 输出trueconsole.log(Array.prototype.__proto__ === Object.prototype); // 输出trueconsole.log(Function.prototype.__proto__ === Object.prototype); // 输出trueconsole.log(Object.prototype.__proto__ === null) // 输出true 除了Object.prototype本身，对象的原型最终指向Object.prototype，null是原型链的顶端。Object.prototype的原型对象为空，Object.prototype是原型对象的源头，继承由此开始。 四、函数也是对象看以下代码：1console.log(Function.__proto__ === Function.prototype) // 输出true 函数也是对象，JavaScript的内置函数Function也不例外，对象Function的__proto__属性指向它的构造函数的prototype属性，Function.prototype即是它的原型对象。 五、constructor属性对象才都有constructor属性，constructor在原型链中作为对象prototype的属性存在，它从对象指向对象的构造函数，每个对象都有构造函数。 六、constructor的顶端123456console.log(String.constructor === Function);console.log(Number.constructor === Function);console.log(Boolean.constructor === Function);console.log(Array.constructor === Function);console.log(Object.constructor === Function);console.log(Function.constructor === Function); 可以看出Function的构造函数就是它自己，所有函数最终都是由Function构造得来，所以constructor属性的顶端是Function。 七、总结1、函数的prototype即是对象的原型对象2、通过对象的__proto__属性一直向上访问prototype属性的一条链即为原型链。3、对象独有的属性：__proto__和constructor；4、函数独有的属性：prototype，但JavaScript中函数也是对象，所以函数也有__proto__和constructor属性；5、constructor属性指向该对象的构造函数，最终指向Function。 参考博文：https://blog.csdn.net/cc18868876837/article/details/81211729","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhy918.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhy918.github.io/tags/JavaScript/"},{"name":"原型链","slug":"原型链","permalink":"https://zhy918.github.io/tags/原型链/"}]}]}